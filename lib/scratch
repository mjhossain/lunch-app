void _openSettings() {
    Navigator.push(
      context,
      MaterialPageRoute(builder: (context) => const SettingsPage()),
    );
  }



Widget _buildNavItem(IconData icon, int index) {
    final isSelected = _selectedIndex == index;
    return NeumorphicButton(
      width: 60,
      height: 60,
      onPressed: () => setState(() => _selectedIndex = index),
      child: Icon(
        icon,
        color: isSelected ? AppColors.primaryColor : AppColors.textColor,
      ),
    );
  }


// timerpage


import 'dart:async';
import 'package:flutter/material.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'dart:math' as math;
import '../theme/colors.dart';
import '../widgets/neumorphic_button.dart';
import 'package:flutter_local_notifications/flutter_local_notifications.dart';

class TimerPage extends StatefulWidget {
  const TimerPage({super.key});

  @override
  State<TimerPage> createState() => _TimerPageState();
}

class _TimerPageState extends State<TimerPage> with TickerProviderStateMixin {
  late AnimationController _timerController;
  late AnimationController _scaleController;
  Timer? _timer;
  bool _isBreak = false;
  int _workDuration = 25;
  int _breakDuration = 5;
  int _remainingTime = 0;
  bool _isRunning = false;
  int _currentRound = 1;

  @override
  void initState() {
    super.initState();
    _loadSettings();
    _timerController = AnimationController(
      vsync: this,
      duration: Duration(minutes: _workDuration),
    );
    _scaleController = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 300),
    );
  }





  Future<void> _loadSettings() async {
    final prefs = await SharedPreferences.getInstance();
    setState(() {
      _workDuration = prefs.getInt('work_duration') ?? 25;
      _breakDuration = prefs.getInt('break_duration') ?? 5;
      _remainingTime = _workDuration * 60;
    });
  }

  // Format seconds into MM:SS
  String _formatTime(int seconds) {
    final minutes = seconds ~/ 60;
    final remainingSeconds = seconds % 60;
    return '${minutes.toString().padLeft(2, '0')}:${remainingSeconds.toString().padLeft(2, '0')}';
  }

// Show local notification with sound
  Future<void> _showNotification(String title, String body) async {
    final FlutterLocalNotificationsPlugin flutterLocalNotificationsPlugin =
    FlutterLocalNotificationsPlugin();

    const AndroidNotificationDetails androidPlatformChannelSpecifics =
    AndroidNotificationDetails(
      'lunch_timer_channel',
      'Lunch Timer Notifications',
      importance: Importance.max,
      priority: Priority.high,
      playSound: true,
      sound: RawResourceAndroidNotificationSound('notification_sound'),
    );

    const DarwinNotificationDetails iOSPlatformChannelSpecifics =
    DarwinNotificationDetails(
      presentSound: true,
      sound: 'notification_sound.aiff',
    );

    const NotificationDetails platformChannelSpecifics = NotificationDetails(
      android: androidPlatformChannelSpecifics,
      iOS: iOSPlatformChannelSpecifics,
    );

    await flutterLocalNotificationsPlugin.show(
      0,
      title,
      body,
      platformChannelSpecifics,
    );
  }


  void _startTimer() {
    final duration = _isBreak ? _breakDuration : _workDuration;
    _remainingTime = duration * 60;
    setState(() => _isRunning = true);

    _timerController.duration = Duration(minutes: duration);
    _timerController.forward(from: 0);

    _scaleController.forward(from: 0);

    _timer = Timer.periodic(const Duration(seconds: 1), (timer) {
      setState(() {
        if (_remainingTime > 0) {
          _remainingTime--;
        } else {
          _timer?.cancel();
          _isRunning = false;
          _handleTimerComplete();
        }
      });
    });
  }

  void _handleTimerComplete() {
    if (!_isBreak) {
      setState(() {
        _isBreak = true;
        _currentRound++;
      });
    } else {
      setState(() => _isBreak = false);
    }
    _showNotification(
      _isBreak ? 'Break Time!' : 'Back to Work!',
      _isBreak ? 'Time for a short break.' : 'Break is over, let\'s focus!',
    );
  }

  void _toggleTimer() {
    if (_isRunning) {
      _timer?.cancel();
      _timerController.stop();
      setState(() => _isRunning = false);
    } else {
      _startTimer();
    }
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        const SizedBox(height: 60),
        ScaleTransition(
          scale: _scaleController,
          child: Text(
            'ROUND $_currentRound',
            style: Theme.of(context).textTheme.titleLarge,
          ),
        ),
        const SizedBox(height: 40),
        Center(
          child: Stack(
            alignment: Alignment.center,
            children: [
              AnimatedBuilder(
                animation: _timerController,
                builder: (context, child) {
                  return CustomPaint(
                    size: const Size(300, 300),
                    painter: TimerPainter(
                      animation: _timerController,
                      backgroundColor: AppColors.shadowColor,
                      color: _isBreak ? AppColors.accentBlue : AppColors.primaryColor,
                    ),
                  );
                },
              ),
              ScaleTransition(
                scale: _scaleController,
                child: Text(
                  _formatTime(_remainingTime),
                  style: Theme.of(context).textTheme.displayLarge,
                ),
              ),
            ],
          ),
        ),
        const SizedBox(height: 40),
        Row(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            NeumorphicButton(
              width: 120,
              onPressed: () {
                _timer?.cancel();
                _timerController.reset();
                setState(() {
                  _remainingTime = (_isBreak ? _breakDuration : _workDuration) * 60;
                  _isRunning = false;
                });
              },
              child: const Text('RESTART'),
            ),
            const SizedBox(width: 20),
            NeumorphicButton(
              width: 120,
              color: _isBreak ? AppColors.accentBlue : AppColors.primaryColor,
              onPressed: _toggleTimer,
              child: Text(
                _isRunning ? 'PAUSE' : 'START',
                style: const TextStyle(color: Colors.white),
              ),
            ),
          ],
        ),
        const SizedBox(height: 20),
        NeumorphicButton(
          width: 260,
          onPressed: () {
            setState(() => _isBreak = !_isBreak);
            _timer?.cancel();
            _timerController.reset();
            _remainingTime = (_isBreak ? _breakDuration : _workDuration) * 60;
            _isRunning = false;
          },
          child: Row(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Text(_isBreak ? 'SWITCH TO WORK' : 'START BREAK'),
              const SizedBox(width: 8),
              Text('${_isBreak ? _breakDuration : _workDuration}:00'),
            ],
          ),
        ),
      ],
    );
  }

  @override
  void dispose() {
    _timer?.cancel();
    _timerController.dispose();
    _scaleController.dispose();
    super.dispose();
  }
}

class TimerPainter extends CustomPainter {
  final Animation<double> animation;
  final Color backgroundColor;
  final Color color;

  TimerPainter({
    required this.animation,
    required this.backgroundColor,
    required this.color,
  }) : super(repaint: animation);

  @override
  void paint(Canvas canvas, Size size) {
    Paint paint = Paint()
      ..color = backgroundColor
      ..strokeWidth = 20
      ..strokeCap = StrokeCap.round
      ..style = PaintingStyle.stroke;

    canvas.drawCircle(size.center(Offset.zero), size.width / 2.0, paint);

    paint.color = color;
    double progress = (1.0 - animation.value) * 2 * math.pi;
    canvas.drawArc(
      Offset.zero & size,
      -math.pi / 2,
      progress,
      false,
      paint,
    );
  }

  @override
  bool shouldRepaint(TimerPainter oldDelegate) {
    return animation.value != oldDelegate.animation.value ||
        color != oldDelegate.color ||
        backgroundColor != oldDelegate.backgroundColor;
  }
}